###### tags: `Two pointer`

# [E] 26. Remove Duplicates from Sorted Array
問題描述：

給定一個已經排序好的整數陣列 nums，將重複的元素刪除，使得每個元素只出現一次，同時返回新的陣列長度。

你必須在原地修改輸入陣列並在使用 O(1) 非額外空間的情況下完成。

範例：
```java=
Input: nums = [1,1,2]
Output: 2, nums = [1,2]
Explanation: 函式應該返回新的長度 2，並且原陣列 nums 的前兩個元素必須是 1 和 2。
不需要考慮新的陣列長度後面的元素。
```
解法：

此問題可以使用兩個指針來解決，一個指向當前位置，另一個指向不重複元素應該填的位置。

因為該陣列已經排序好了，因此重複的元素肯定是相連的，可以從頭到尾掃描陣列，當找到不同的元素時，就把這個元素放到不重複元素應該填的位置上。

最後，返回不重複元素的個數，即可。

這種解題方式的精髓在於使用了兩個指針來分別指向不同的位置，從而實現在原地修改輸入陣列的效果，而且不需要使用額外的空間，時間複雜度也非常優秀，是一種非常優雅和經典的算法設計。

程式碼實現：
```java=
class Solution {
    public int removeDuplicates(int[] nums) {
        // 定義指針 i，初始值為 1，指向不重複元素應該填的位置
        int i = 1;

        // 如果陣列為空或長度為 0，則直接返回 0
        if(nums == null || nums.length == 0){
            return 0;
        }

        // 遍歷整個陣列
        for(int j = 0; j < nums.length; j++){
            // 如果發現不重複的元素，將其放到指針 i 所指向的位置
            if(nums[j] != nums[i - 1]){
                nums[i++] = nums[j++];
            }  
        }

        // 返回不重複元素的個數，即為指針 i 所指向的位置
        return i;
    }
}
```

解題思路:
1. 如果陣列為空或長度為 0，則直接返回 0。
1. 定義兩個指針 i 和 j，初始值分別為 1 和 0，分別指向不重複元素應該填的位置和當前要比較的位置。
1. 遍歷整個陣列，當 nums[j] 等於 nums[i - 1] 時，表示發現了一個重複元素，此時 j 指向下一個位置；否則，將 nums[j] 放到 nums[i] 的位置上，然後 i 向後移動一位，j 指向下一個位置。
1. 重複執行步驟 3，直到 j 遍歷完整個陣列。
1. 返回不重複元素的個數，即為 i。